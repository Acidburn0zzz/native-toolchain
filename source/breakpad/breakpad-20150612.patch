diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/dump_writer_common/raw_context_cpu.h breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/raw_context_cpu.h
--- breakpad-20150612-p1/src/client/linux/dump_writer_common/raw_context_cpu.h	2014-10-01 02:51:23.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/raw_context_cpu.h	2017-01-16 01:59:12.190684190 -0800
@@ -44,6 +44,8 @@
 typedef MDRawContextARM64 RawContextCPU;
 #elif defined(__mips__)
 typedef MDRawContextMIPS RawContextCPU;
+#elif defined(__PPC64__)
+typedef MDRawContextPPC RawContextCPU;
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/dump_writer_common/thread_info.cc breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/thread_info.cc
--- breakpad-20150612-p1/src/client/linux/dump_writer_common/thread_info.cc	2015-04-21 14:34:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/thread_info.cc	2017-01-16 02:29:48.268408703 -0800
@@ -264,7 +264,26 @@
   out->float_save.fir = mcontext.fpc_eir;
 #endif
 }
-#endif  // __mips__
+#elif defined (__PPC__)
+
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.nip;
+}
+void ThreadInfo::FillCPUContext(RawContextCPU* out ) const {
+  out->context_flags = MD_CONTEXT_PPC_FULL;
+
+  for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; ++i)
+    out->gpr[i] = regs.gpr[i];
+    
+  out->srr0 = regs.nip;
+  out->srr1 = regs.msr;
+  out->cr = regs.ccr;
+  out->xer = regs.xer;
+  out->lr = regs.link;
+  out->ctr = regs.ctr;
+  
+}
+#endif  // __PPC___
 
 void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
   assert(gp_regs || size);
@@ -288,6 +307,11 @@
     *fp_regs = &mcontext.fpregs;
   if (size)
     *size = sizeof(mcontext.fpregs);
+#elif defined(__PPC64__)
+  if (fp_regs)
+    *fp_regs = &regs;
+  if (size)
+    *size = sizeof(regs);
 #else
   if (fp_regs)
     *fp_regs = &fpregs;
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/dump_writer_common/thread_info.h breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/thread_info.h
--- breakpad-20150612-p1/src/client/linux/dump_writer_common/thread_info.h	2015-04-21 14:34:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/thread_info.h	2017-01-16 01:59:12.190684190 -0800
@@ -71,6 +71,8 @@
 #elif defined(__mips__)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
+#elif defined(__PPC__)
+  struct pt_regs regs;
 #endif
 
   // Returns the instruction pointer (platform-dependent impl.).
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/dump_writer_common/ucontext_reader.cc breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/ucontext_reader.cc
--- breakpad-20150612-p1/src/client/linux/dump_writer_common/ucontext_reader.cc	2015-04-15 12:28:11.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/ucontext_reader.cc	2017-01-16 01:59:12.190684190 -0800
@@ -248,6 +248,35 @@
   out->float_save.fir = uc->uc_mcontext.fpc_eir;  // Unused.
 #endif
 }
+#elif defined(__PPC64__)
+
+  uintptr_t UContextReader::GetStackPointer(const struct ucontext* uc) {
+  return uc->uc_mcontext.regs->gpr[1];
+  }
+
+  uintptr_t UContextReader::GetInstructionPointer(const struct ucontext* uc) {
+  return uc->uc_mcontext.regs->nip;
+  }
+
+  void UContextReader::FillCPUContext(RawContextCPU *out, const ucontext *uc,
+                                      const struct _libc_fpstate* fpregs) {
+  typedef unsigned long greg_t;
+  const greg_t* regs = uc->uc_mcontext.gp_regs;
+
+  out->context_flags = MD_CONTEXT_PPC_FULL;
+
+  for (int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; ++i)
+  	out->gpr[i] = regs[i];
+
+  out->vrsave = uc->uc_mcontext.v_regs->vrsave;
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_PPC_FPR_COUNT; ++i)
+  	out->float_save.fpregs[i] = fpregs->fpregs[i];
+
+  out->float_save.fpscr = fpregs->fpscr;
+}
+
 #endif
 
+
 }  // namespace google_breakpad
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/dump_writer_common/ucontext_reader.h breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/ucontext_reader.h
--- breakpad-20150612-p1/src/client/linux/dump_writer_common/ucontext_reader.h	2014-10-01 02:51:23.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/dump_writer_common/ucontext_reader.h	2017-01-16 02:31:45.999926657 -0800
@@ -37,6 +37,15 @@
 #include "common/memory.h"
 #include "google_breakpad/common/minidump_format.h"
 
+#if defined(__PPC__)
+struct _libc_fpstate
+  {
+        double fpregs[32];
+        double fpscr;
+        unsigned int _pad[2];
+  };
+#endif
+
 namespace google_breakpad {
 
 // Wraps platform-dependent implementations of accessors to ucontext structs.
@@ -54,6 +63,9 @@
 #elif defined(__aarch64__)
   static void FillCPUContext(RawContextCPU *out, const ucontext *uc,
                              const struct fpsimd_context* fpregs);
+#elif defined(__PPC__)
+  static void FillCPUContext(RawContextCPU *out, const ucontext *uc,
+                             const struct _libc_fpstate* fpregs_); 
 #else
   static void FillCPUContext(RawContextCPU *out, const ucontext *uc);
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/handler/exception_handler.cc breakpad-20150612-p1_ppc/src/client/linux/handler/exception_handler.cc
--- breakpad-20150612-p1/src/client/linux/handler/exception_handler.cc	2015-05-15 01:43:01.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/handler/exception_handler.cc	2017-01-16 01:59:12.182684098 -0800
@@ -436,9 +436,9 @@
   // In case of MIPS Linux FP state is already part of struct ucontext
   // and 'float_state' is not a member of CrashContext.
   struct ucontext *uc_ptr = (struct ucontext*)uc;
-  if (uc_ptr->uc_mcontext.fpregs) {
+  if (uc_ptr->uc_mcontext.fp_regs){
     memcpy(&context.float_state,
-           uc_ptr->uc_mcontext.fpregs,
+	   uc_ptr->uc_mcontext.fp_regs,
            sizeof(context.float_state));
   }
 #endif
@@ -659,7 +659,7 @@
 
 #if !defined(__ARM_EABI__) && !defined(__aarch64__) && !defined(__mips__)
   // FPU state is not part of ARM EABI ucontext_t.
-  memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
+  memcpy(&context.float_state, context.context.uc_mcontext.fp_regs,
          sizeof(context.float_state));
 #endif
   context.tid = sys_gettid();
@@ -682,6 +682,9 @@
 #elif defined(__mips__)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.pc);
+#elif defined(__PPC64__)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.gp_regs[PT_NIP]);
 #else
 #error "This code has not been ported to your platform yet."
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/handler/exception_handler.h breakpad-20150612-p1_ppc/src/client/linux/handler/exception_handler.h
--- breakpad-20150612-p1/src/client/linux/handler/exception_handler.h	2014-09-23 13:30:09.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/handler/exception_handler.h	2017-01-16 01:59:12.182684098 -0800
@@ -192,11 +192,21 @@
     siginfo_t siginfo;
     pid_t tid;  // the crashing thread.
     struct ucontext context;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) 
     // #ifdef this out because FP state is not part of user ABI for Linux ARM.
     // In case of MIPS Linux FP state is already part of struct
     // ucontext so 'float_state' is not required.
-    fpstate_t float_state;
+    #if defined(__PPC__)
+       struct _libc_fpstate
+       {
+     	   double fpregs[32];
+           double fpscr;
+           unsigned int _pad[2];
+       };
+       struct _libc_fpstate float_state;
+    #else 
+       fpstate_t float_state;
+    #endif
 #endif
   };
 
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/microdump_writer/microdump_writer.cc breakpad-20150612-p1_ppc/src/client/linux/microdump_writer/microdump_writer.cc
--- breakpad-20150612-p1/src/client/linux/microdump_writer/microdump_writer.cc	2015-05-15 01:43:01.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/microdump_writer/microdump_writer.cc	2017-01-16 02:35:08.941375494 -0800
@@ -64,7 +64,7 @@
                   const char* product_info,
                   LinuxDumper* dumper)
       : ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__PPC__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -178,6 +178,8 @@
     const char kArch[] = "x86";
 #elif defined(__mips__)
     const char kArch[] = "mips";
+#elif defined(__PPC__)
+    const char kArch[] = "ppc";
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -383,8 +385,10 @@
   void* Alloc(unsigned bytes) { return dumper_->allocator()->Alloc(bytes); }
 
   const struct ucontext* const ucontext_;
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__PPC__)
   const google_breakpad::fpstate_t* const float_state_;
+#elif defined(__PPC__)
+  const _libc_fpstate* const float_state_ = NULL;
 #endif
   LinuxDumper* dumper_;
   const MappingList& mapping_list_;
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/linux_core_dumper.cc breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_core_dumper.cc
--- breakpad-20150612-p1/src/client/linux/minidump_writer/linux_core_dumper.cc	2015-04-21 14:34:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_core_dumper.cc	2017-01-16 01:59:12.190684190 -0800
@@ -110,6 +110,8 @@
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
+#elif defined(__PPC__)
+  memcpy(&stack_pointer, &info->regs.gpr[1], sizeof(info->regs.gpr[1]));
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/linux_dumper.h breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_dumper.h
--- breakpad-20150612-p1/src/client/linux/minidump_writer/linux_dumper.h	2015-04-15 12:28:11.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_dumper.h	2017-01-16 01:59:12.190684190 -0800
@@ -55,7 +55,7 @@
 #if defined(__i386) || defined(__ARM_EABI__) || \
  (defined(__mips__) && _MIPS_SIM == _ABIO32)
 typedef Elf32_auxv_t elf_aux_entry;
-#elif defined(__x86_64) || defined(__aarch64__) || \
+#elif defined(__x86_64) || defined(__aarch64__) || defined(__PPC64__) ||\
      (defined(__mips__) && _MIPS_SIM != _ABIO32)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
--- breakpad-20150612-p1/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc	2014-04-08 10:36:11.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc	2017-01-16 01:59:12.190684190 -0800
@@ -41,7 +41,7 @@
 #include "common/scoped_ptr.h"
 #include "third_party/lss/linux_syscall_support.h"
 
-#if defined(__ARM_EABI__)
+#if defined(__ARM_EABI__)  || defined(__PPC__)
 #define TID_PTR_REGISTER "r3"
 #elif defined(__aarch64__)
 #define TID_PTR_REGISTER "x3"
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/linux_ptrace_dumper.cc breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
--- breakpad-20150612-p1/src/client/linux/minidump_writer/linux_ptrace_dumper.cc	2015-04-21 14:34:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_ptrace_dumper.cc	2017-01-16 01:59:12.190684190 -0800
@@ -271,6 +271,8 @@
 #elif defined(__mips__)
   stack_pointer =
       reinterpret_cast<uint8_t*>(info->mcontext.gregs[MD_CONTEXT_MIPS_REG_SP]);
+#elif defined(__PPC__)
+  memcpy(&stack_pointer, &info->regs.gpr[1], sizeof(info->regs.gpr[1]));
 #else
 #error "This code hasn't been ported to your platform yet."
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
--- breakpad-20150612-p1/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc	2015-04-21 14:34:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc	2017-01-16 01:59:12.190684190 -0800
@@ -439,6 +439,8 @@
     pid_t* process_tid_location = (pid_t*)(one_thread.regs.ecx);
 #elif defined(__x86_64)
     pid_t* process_tid_location = (pid_t*)(one_thread.regs.rcx);
+#elif defined(__PPC__)
+    pid_t* process_tid_location = (pid_t*)(one_thread.regs.gpr[3]);
 #elif defined(__mips__)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.gregs[1]);
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/minidump_writer.cc breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/minidump_writer.cc
--- breakpad-20150612-p1/src/client/linux/minidump_writer/minidump_writer.cc	2015-04-15 12:28:11.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/minidump_writer.cc	2017-01-16 02:37:30.384832281 -0800
@@ -132,7 +132,7 @@
       : fd_(minidump_fd),
         path_(minidump_path),
         ucontext_(context ? &context->context : NULL),
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__PPC__)
         float_state_(context ? &context->float_state : NULL),
 #endif
         dumper_(dumper),
@@ -378,7 +378,7 @@
         if (!cpu.Allocate())
           return false;
         my_memset(cpu.get(), 0, sizeof(RawContextCPU));
-#if !defined(__ARM_EABI__) && !defined(__mips__)
+#if !defined(__ARM_EABI__) && !defined(__mips__) 
         UContextReader::FillCPUContext(cpu.get(), ucontext_, float_state_);
 #else
         UContextReader::FillCPUContext(cpu.get(), ucontext_);
@@ -805,7 +805,7 @@
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__PPC__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -954,6 +954,8 @@
     sys_info->processor_architecture =
 #if defined(__aarch64__)
         MD_CPU_ARCHITECTURE_ARM64;
+#elif defined(__PPC__)
+        MD_CPU_ARCHITECTURE_PPC;
 #else
         MD_CPU_ARCHITECTURE_ARM;
 #endif
@@ -1246,7 +1248,11 @@
 
   const struct ucontext* const ucontext_;  // also from the signal handler
 #if !defined(__ARM_EABI__) && !defined(__mips__)
-  const google_breakpad::fpstate_t* const float_state_;  // ditto
+  #if defined(__PPC__)
+	const struct _libc_fpstate* const float_state_=NULL;
+  #else
+  	const google_breakpad::fpstate_t* const float_state_;  // ditto
+  #endif
 #endif
   LinuxDumper* dumper_;
   MinidumpFileWriter minidump_writer_;
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/minidump_writer.h breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/minidump_writer.h
--- breakpad-20150612-p1/src/client/linux/minidump_writer/minidump_writer.h	2014-10-28 09:45:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/minidump_writer.h	2017-01-16 01:59:12.190684190 -0800
@@ -47,7 +47,7 @@
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
-#elif !defined(__ARM_EABI__) && !defined(__mips__)
+#elif !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__PPC__)
 typedef struct _libc_fpstate fpstate_t;
 #endif
 
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/client/linux/minidump_writer/minidump_writer_unittest.cc breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/minidump_writer_unittest.cc
--- breakpad-20150612-p1/src/client/linux/minidump_writer/minidump_writer_unittest.cc	2014-04-08 10:36:11.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/client/linux/minidump_writer/minidump_writer_unittest.cc	2017-01-16 01:59:12.190684190 -0800
@@ -536,6 +536,8 @@
   context.context.uc_mcontext.arm_sp = invalid_stack_pointer;
 #elif defined(__aarch64__)
   context.context.uc_mcontext.sp = invalid_stack_pointer;
+#elif defined(__PPC__)
+  context.context.uc_mcontext.regs->gpr[1] = invalid_stack_pointer;
 #elif defined(__mips__)
   context.context.uc_mcontext.gregs[MD_CONTEXT_MIPS_REG_SP] =
       invalid_stack_pointer;
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/third_party/curl/curlbuild.h breakpad-20150612-p1_ppc/src/third_party/curl/curlbuild.h
--- breakpad-20150612-p1/src/third_party/curl/curlbuild.h	2015-04-15 12:28:11.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/third_party/curl/curlbuild.h	2017-01-16 01:59:12.082682948 -0800
@@ -154,7 +154,7 @@
 #endif
 
 /* The size of `long', as computed by sizeof. */
-#if defined(_M_X64) || (defined(__x86_64__) && !defined(__ILP32__)) ||      \
+#if defined(_M_X64) || (defined(__x86_64__) && !defined(__ILP32__)) || defined(__PPC64__) ||    \
     defined(__aarch64__) || (defined(__mips__) && _MIPS_SIM == _ABI64)
 #define CURL_SIZEOF_LONG 8
 #else
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/third_party/lss/linux_syscall_support.h breakpad-20150612-p1_ppc/src/third_party/lss/linux_syscall_support.h
--- breakpad-20150612-p1/src/third_party/lss/linux_syscall_support.h	2014-07-31 19:22:56.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/third_party/lss/linux_syscall_support.h	2017-01-16 01:59:12.054682626 -0800
@@ -1411,6 +1411,9 @@
 #ifndef __NR_pwrite64
 #define __NR_pwrite64           180
 #endif
+#ifndef __NR_mmap2
+#define __NR_mmap2              192
+#endif
 #ifndef __NR_ugetrlimit
 #define __NR_ugetrlimit         190
 #endif
diff -urx '*.guess' -x '*.sub' -x missing -x '*.m4' -x autotools -x '*.o' -x '.d*' -x '*.in' breakpad-20150612-p1/src/tools/linux/md2core/minidump-2-core.cc breakpad-20150612-p1_ppc/src/tools/linux/md2core/minidump-2-core.cc
--- breakpad-20150612-p1/src/tools/linux/md2core/minidump-2-core.cc	2015-04-21 14:34:14.000000000 -0700
+++ breakpad-20150612-p1_ppc/src/tools/linux/md2core/minidump-2-core.cc	2017-01-16 02:39:07.987095604 -0800
@@ -155,7 +155,11 @@
   elf_timeval    pr_stime;      /* System time                               */
   elf_timeval    pr_cutime;     /* Cumulative user time                      */
   elf_timeval    pr_cstime;     /* Cumulative system time                    */
+#if defined(__PPC__)
+  pt_regs pr_reg;
+#else
   user_regs_struct pr_reg;      /* CPU registers                             */
+#endif
   uint32_t       pr_fpvalid;    /* True if math co-processor being used      */
 } prstatus;
 
@@ -211,17 +215,17 @@
 
   struct Thread {
     pid_t tid;
-#if defined(__mips__)
+#if defined(__PPC__)
+    pt_regs regs;
+#elif defined(__mips__)
     mcontext_t mcontext;
-#else  // __mips__
-    user_regs_struct regs;
-#if defined(__i386__) || defined(__x86_64__)
+#elif defined(__i386__) || defined(__x86_64__)
     user_fpregs_struct fpregs;
-#endif  // __i386__ || __x86_64__
-#if defined(__i386__)
+#elif defined(__i386__)
     user_fpxregs_struct fpxregs;
-#endif  // __i386__
-#endif  // __mips__
+#else  
+    user_regs_struct regs;
+#endif  
     uintptr_t stack_addr;
     const uint8_t* stack;
     size_t stack_length;
@@ -402,6 +406,23 @@
   thread->mcontext.fpc_eir = rawregs->float_save.fir;
 #endif
 }
+#elif defined(__PPC64__)
+  static void
+  ParseThreadRegisters(CrashedProcess::Thread* thread,
+                     const MinidumpMemoryRange& range) {
+  const MDRawContextPPC64* rawregs = range.GetData<MDRawContextPPC64>(0);
+
+  for(int i = 0; i < MD_CONTEXT_PPC64_GPR_COUNT; i++)
+  thread->regs.gpr[i] = rawregs->gpr[i];
+
+  thread->regs.nip = rawregs->srr0;
+  thread->regs.msr = rawregs->srr1;
+  thread->regs.ctr = rawregs->ctr;
+  thread->regs.xer = rawregs->xer;
+  thread->regs.link =  rawregs->lr;
+  thread->regs.ccr = rawregs->cr;
+
+}
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -472,6 +493,14 @@
             "This version of minidump-2-core only supports mips (32bit).\n");
     _exit(1);
   }
+#elif defined(__PPC64__)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_PPC) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports PowerPC (64bit)%s.\n",
+            sysinfo->processor_architecture == MD_CPU_ARCHITECTURE_PPC ?
+            ",\nbut the minidump file is from a 32bit machine" : "");
+    _exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -767,6 +796,8 @@
   pr.pr_pid = thread.tid;
 #if defined(__mips__)
   memcpy(&pr.pr_reg, &thread.mcontext.gregs, sizeof(user_regs_struct));
+#elif defined(__PPC__)
+  memcpy(&pr.pr_reg, &thread.regs, sizeof(pt_regs));
 #else
   memcpy(&pr.pr_reg, &thread.regs, sizeof(user_regs_struct));
 #endif
@@ -782,6 +813,16 @@
     return false;
   }
 
+#if !defined(__PPC__)
+  nhdr.n_descsz = sizeof(user_fpregs_struct);
+  nhdr.n_type = NT_FPREGSET;
+  if (!writea(1, &nhdr, sizeof(nhdr)) ||
+      !writea(1, "CORE\0\0\0\0", 8) ||
+      !writea(1, &thread.fpregs, sizeof(user_fpregs_struct))) {
+    return false;
+  }
+#endif
+
 #if defined(__i386__) || defined(__x86_64__)
   nhdr.n_descsz = sizeof(user_fpregs_struct);
   nhdr.n_type = NT_FPREGSET;
@@ -1134,6 +1175,10 @@
                   sizeof(Nhdr) + 8 + crashinfo.auxv_length +
                   crashinfo.threads.size() * (
                     (sizeof(Nhdr) + 8 + sizeof(prstatus))
+//check sanity
+#if !defined(__PPC__)
+                   +  sizeof(Nhdr) + 8 + sizeof(user_fpregs_struct)
+#endif
 #if defined(__i386__) || defined(__x86_64__)
                    + sizeof(Nhdr) + 8 + sizeof(user_fpregs_struct)
 #endif
